<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>imow.api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>imow.api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import asyncio
import json
import logging
import sys
from datetime import datetime, timedelta
from typing import Tuple, Union, List
from urllib.parse import quote

import aiohttp
from aiohttp import ClientSession, ClientResponseError
from bs4 import BeautifulSoup
from furl import furl

from imow.common.actions import IMowActions
from imow.common.consts import IMOW_OAUTH_URI, IMOW_API_URI
from imow.common.exceptions import (
    LoginError,
    ApiMaintenanceError,
    LanguageNotFoundError,
)
from imow.common.messages import Messages
from imow.common.mowerstate import MowerState
from imow.common.package_descriptions import (
    python_major,
    python_minor,
    package_name,
)

logger = logging.getLogger(&#34;imow&#34;)

try:
    assert sys.version_info &gt;= (int(python_major), int(python_minor))
except AssertionError:
    raise RuntimeError(
        f&#34;{package_name!r} requires Python {python_major}.{python_minor}+ (You have Python {sys.version})&#34;
    )
if (
    sys.version_info[0] == 3
    and sys.version_info[1] &gt;= 8
    and sys.platform.startswith(&#34;win&#34;)
):
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())


class IMowApi:
    def __init__(
        self,
        email: str = None,
        password: str = None,
        token: str = None,
        aiohttp_session: ClientSession = None,
        lang: str = &#34;en&#34;,
    ) -&gt; None:
        self.http_session: ClientSession = aiohttp_session
        self.csrf_token: str = &#34;&#34;
        self.requestId: str = &#34;&#34;
        self.access_token: str = token
        self.token_expires: datetime = None
        self.api_email: str = email
        self.api_password: str = password
        self.lang = lang
        self.messages_user = None
        self.messages_en = None

    async def close(self):
        &#34;&#34;&#34;Cleanup the aiohttp Session&#34;&#34;&#34;
        await asyncio.sleep(0.250)
        await self.http_session.close()

    async def check_api_maintenance(self) -&gt; None:
        url = &#34;https://app-api-maintenance-r-euwe-4bf2d8.azurewebsites.net/maintenance/&#34;

        headers = {
            &#34;Authorization&#34;: &#34;&#34;,
        }
        response = await self.api_request(url, &#34;GET&#34;, headers=headers)
        status = json.loads(await response.text())
        logger.debug(status)
        if status[&#34;serverDisrupted&#34;] or status[&#34;serverDown&#34;]:
            msg = (
                f&#34;iMow API is under Maintenance -&gt; &#34;
                f&#39;serverDisrupted: {status[&#34;serverDisrupted&#34;]}, serverDown: {status[&#34;serverDown&#34;]}, &#39;
                f&#39;affectedTill {status[&#34;affectedTill&#34;]}&#39;
            )
            raise ApiMaintenanceError(msg)

    async def get_token(
        self,
        email: str = &#34;&#34;,
        password: str = &#34;&#34;,
        force_reauth=False,
        return_expire_time=False,
    ) -&gt; Union[Tuple[str, datetime], str]:
        &#34;&#34;&#34;
        look for a token, if present, return. Else authenticate and store new token
        :param return_expire_time:
        :param email: stihl webapp login email non-url-encoded
        :param password: stihl webapp login password
        :param force_reauth: Force a re-authentication with username and password
        :return: tuple, the access token and a datetime object containing the expire date
        &#34;&#34;&#34;

        if not self.access_token or force_reauth:
            if email and password:
                self.api_password = password
                self.api_email = email
            if force_reauth:
                await self.api_logout()
                self.csrf_token = &#34;&#34;
                self.requestId = &#34;&#34;
                self.access_token: str = &#34;&#34;
                self.token_expires: datetime = None
            if not self.api_email and not self.api_password:
                raise LoginError(
                    &#34;Got no credentials to authenticate, please provide&#34;
                )
            await self.__authenticate(self.api_email, self.api_password)
            logger.debug(&#34;Get Token: Re-Authenticate&#34;)

        await self.validate_token()
        if return_expire_time:
            return self.access_token, self.token_expires
        else:
            return self.access_token

    async def api_logout(self):
        if not self.http_session or self.http_session.closed:
            self.http_session = aiohttp.ClientSession(raise_for_status=True)
        async with self.http_session.post(
            &#34;https://oauth2.imow.stihl.com/authentication/logout/&#34;,
            data={
                &#34;csrf-token&#34;: self.csrf_token,
                &#34;logoutUrl&#34;: &#34;https://app.imow.stihl.com&#34;,
                &#34;clientId&#34;: &#34;9526273B-1477-47C6-801C-4356F58EF883&#34;,
                &#34;cancelUrl&#34;: &#34;https://app.imow.stihl.com&#34;,
            },
        ) as resp:
            await resp.read()
        self.http_session.cookie_jar.clear_domain(&#34;https://app.imow.stihl.com&#34;)
        self.http_session.cookie_jar.clear_domain(
            &#34;https://oauth2.imow.stihl.com/&#34;
        )

    async def validate_token(self, explicit_token: str = None) -&gt; bool:
        old_token = None
        if explicit_token:
            # save old instance token and place temp token for validation
            old_token = self.access_token
            self.access_token = explicit_token

        await self.receive_mowers()

        if explicit_token:
            # Reset instance token
            self.access_token = old_token
        return True

    async def __authenticate(
        self, email: str, password: str
    ) -&gt; List[str, str, aiohttp.ClientResponse]:
        &#34;&#34;&#34;
        try the authentication request with fetched csrf and requestId payload
        :param email: stihl webapp login email non-url-encoded
        :param password: stihl webapp login password
        :return: the newly created access token, and expire time besides the legacy response
        &#34;&#34;&#34;

        await self.__fetch_new_csrf_token_and_request_id()
        url = f&#34;{IMOW_OAUTH_URI}/authentication/authenticate/?lang={self.lang}&#34;
        encoded_mail = quote(email)
        encoded_password = quote(password)
        payload = (
            f&#34;mail={encoded_mail}&amp;password={encoded_password}&#34;
            f&#34;&amp;csrf-token={self.csrf_token}&amp;requestId={self.requestId} &#34;
        )
        headers = {
            &#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded&#34;,
        }
        response = await self.api_request(
            url, &#34;POST&#34;, payload=payload, headers=headers
        )

        response_url_query_args = furl(response.real_url).fragment.args
        if &#34;access_token&#34; not in response_url_query_args:
            raise LoginError(
                &#34;STIHL iMow did not return an access_token, check your credentials&#34;
            )

        self.access_token = response_url_query_args[&#34;access_token&#34;]
        self.token_expires = datetime.now() + timedelta(
            seconds=int(response_url_query_args[&#34;expires_in&#34;])
        )
        return self.access_token, self.token_expires, response

    async def __fetch_new_csrf_token_and_request_id(self) -&gt; List[str, str]:
        &#34;&#34;&#34;
        Fetch a new csrf_token and requestId to do the authentication as expected by the api
        csrf_token and requestId are used as payload within authentication
        &#34;&#34;&#34;

        # URL needs whole redirect query parameter
        url = (
            f&#34;{IMOW_OAUTH_URI}/authentication/?lang=de_DE&amp;authorizationRedirectUrl=https%3A%2F%2Foauth2&#34;
            &#34;.imow.stihl.com%2Fauthorization%2F%3Fresponse_type%3Dtoken%26client_id%3D9526273B-1477-47C6-801C&#34;
            &#34;-4356F58EF883%26redirect_uri%3Dhttps%253A%252F%252Fapp.imow.stihl.com%252F%2523%252Fauthorize%26state&#34;
        )
        response = await self.api_request(url, &#34;GET&#34;)

        soup = BeautifulSoup(await response.text(), &#34;html.parser&#34;)
        try:
            upstream_csrf_token = soup.find(
                &#34;input&#34;, {&#34;name&#34;: &#34;csrf-token&#34;}
            ).get(&#34;value&#34;)
            upstream_request_id = soup.find(
                &#34;input&#34;, {&#34;name&#34;: &#34;requestId&#34;}
            ).get(&#34;value&#34;)
        except AttributeError:
            raise ProcessLookupError(
                &#34;Did not find necessary csrf token and/or request id in html source&#34;
            )

        self.csrf_token = upstream_csrf_token
        self.requestId = upstream_request_id
        logger.debug(&#34;CSRF: new token and request id &lt;redacted&gt;&#34;)
        return self.csrf_token, self.requestId

    async def fetch_messages(self):
        try:
            url_en = (
                &#34;https://app.imow.stihl.com/assets/i18n/animations/en.json&#34;
            )
            async with self.http_session.request(&#34;GET&#34;, url_en) as response_en:
                i18n_en = json.loads(await response_en.text())
            self.messages_en = Messages(i18n_en)
            if self.lang != &#34;en&#34;:
                url_user = f&#34;https://app.imow.stihl.com/assets/i18n/animations/{self.lang}.json&#34;
                async with self.http_session.request(
                    &#34;GET&#34;, url_user
                ) as response_user:
                    i18n_user = json.loads(await response_user.text())
                    self.messages_user = Messages(i18n_user)
            else:
                self.messages_user = self.messages_en

        except ClientResponseError as e:
            if e.status == 404:
                raise LanguageNotFoundError(
                    f&#34;Language-File &#39;{self.lang}.json&#39; not found on imow upstream (&#34;
                    f&#34;https://app.imow.stihl.com/assets/i18n/animations/{self.lang}.json)&#34;
                )

    async def api_request(
        self, url, method, payload=None, headers=None
    ) -&gt; aiohttp.ClientResponse:
        &#34;&#34;&#34;
        Do a standardized request against the stihl imow webapi, with predefined headers
        :param url: The target URL
        :param method: The Method to use
        :param payload: optional payload
        :param headers: optional update headers
        :return: the aiohttp.ClientResponse
        &#34;&#34;&#34;
        if not self.http_session or self.http_session.closed:
            self.http_session = aiohttp.ClientSession(raise_for_status=True)
        if not self.messages_en:
            await self.fetch_messages()
        if (
            self.token_expires
            and (self.token_expires - datetime.now()).days &lt;= 1
        ):
            logger.info(
                &#34;Fetching new access_token because old one expires in less than 1 day&#34;
            )
            await self.get_token(force_reauth=True)

        if not payload:
            payload = {}

        headers_obj = {
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0&#34;,
            &#34;Accept&#34;: &#34;application/json, text/plain, */*&#34;,
            &#34;Accept-Language&#34;: &#34;de,en-US;q=0.7,en;q=0.3&#34;,
            &#34;Authorization&#34;: f&#39;Bearer {self.access_token if self.access_token else &#34;&#34;}&#39;,
            &#34;Origin&#34;: &#34;https://app.imow.stihl.com&#34;,
            &#34;DNT&#34;: &#34;1&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Referer&#34;: &#34;https://app.imow.stihl.com/&#34;,
            &#34;Pragma&#34;: &#34;no-cache&#34;,
            &#34;Cache-Control&#34;: &#34;no-cache&#34;,
            &#34;TE&#34;: &#34;Trailers&#34;,
            &#34;Content-Type&#34;: &#34;application/json&#34;,
        }
        if headers:
            headers_obj.update(headers)
        try:
            async with self.http_session.request(
                method, url, headers=headers_obj, data=payload
            ) as response:
                await response.read()
                response.raise_for_status()
                return response
        except ClientResponseError as e:
            if e.status == 500:
                await self.check_api_maintenance()
            raise e

    def validate_and_fix_datetime(self, value) -&gt; str:
        &#34;&#34;&#34;
        Try to convert and validate the given string from &#34;%Y-%m-%d %H:%M&#34; or &#34;%Y-%m-%d %H:%M:%S into a datetime object and give the needed &#34;%Y-%m-%d %H:%M&#34; string back.
        :param value: the string tobe checked
        :return: the correctly formated string
        &#34;&#34;&#34;
        try:
            datetime_object = datetime.strptime(value, &#34;%Y-%m-%d %H:%M&#34;)
            return datetime_object.strftime(&#34;%Y-%m-%d %H:%M&#34;)
        except ValueError as ve:
            logger.warn(
                f&#34;  Try fixing given time format because {ve} in {value}&#34;
            )
            try:
                datetime_object = datetime.strptime(value, &#34;%Y-%m-%d %H:%M:%S&#34;)
                return datetime_object.strftime(&#34;%Y-%m-%d %H:%M&#34;)
            except ValueError as ve2:
                raise ValueError(
                    f&#39;Unsupported &#34;time&#34; argument: {value} -&gt; {ve2}&#39;
                )

    async def intent(
        self,
        imow_action: IMowActions,
        mower_name: str = &#34;&#34;,
        mower_id: str = &#34;&#34;,
        mower_external_id: str = &#34;&#34;,
        first_action_value_param: any = &#34;&#34;,
        second_action_value_param: any = &#34;&#34;,
        **kwargs,
    ) -&gt; aiohttp.ClientResponse:
        &#34;&#34;&#34;
        Intent to do a action. This seems to create a job object upstream. The action object contains an action Enum,
        the action Value is &lt;MowerExternalId&gt; or &lt;MowerExternalId,DurationInMunitesDividedBy10,StartPoint&gt; if
        startMowing is chosen

        :param imow_action: Anything from imow.common.actions
        :param mower_name: sth to identify which mower is used
        :param mower_id: sth to identify which mower is used
        :param mower_external_id:
            necessary identifier for the mowers for actions.
            This is looked up, if only mower_name or mower_id is provided

        :param first_action_value_param: first argument passed into the action call request to the api. Can be one of the following contents:
            A duration: minutes of intented mowing. Used by START_MOWING_FROM_POINT. Defaults to &#39;30&#39; minutes.
            A starttime: a datetime when to start mowing. I.e. &#39;2023-08-12 20:50&#39; used by START_MOWING

        :param second_action_value_param: second argument passed into the action call request to the api. Can be one of the following contents:
            A startpoint: from which the mowing shall start. Used by START_MOWING_FROM_POINT. Defaults to &#39;0&#39;.
            An endtime: a datetime when to stop mowing. I.e. &#39;2023-08-12 20:50&#39; used by START_MOWING
        :return:
        &#34;&#34;&#34;
        if not mower_external_id and not mower_id and not mower_name:
            raise AttributeError(
                &#34;Need some mower to work on. Please specify mower_[name|id|action_id]&#34;
            )
        if not mower_external_id and mower_name:
            mower_external_id = await self.get_mower_action_id_from_name(
                mower_name
            )
        if not mower_external_id and mower_id:
            mower_external_id = await self.get_mower_action_id_from_id(
                mower_id
            )

        if len(mower_external_id) &lt; 16:
            raise AttributeError(
                f&#34;Invalid mower_action_id, need exactly 16 chars, got {len(mower_external_id)} in {mower_external_id}&#34;
            )

        url = f&#34;{IMOW_API_URI}/mower-actions/&#34;

        given_kwargs = kwargs.items()
        if len(given_kwargs) &gt; 0:
            logger.debug(
                &#34;Translating given intent **kwargs to action_value_param&#34;
            )
            for key, value in given_kwargs:
                logger.debug(&#34;  {0} = {1}&#34;.format(key, value))
                if key == &#34;duration&#34;:
                    first_action_value_param = value
                if key == &#34;startpoint&#34;:
                    second_action_value_param = value

                if key == &#34;starttime&#34;:
                    first_action_value_param = self.validate_and_fix_datetime(
                        value
                    )
                if key == &#34;endtime&#34;:
                    second_action_value_param = self.validate_and_fix_datetime(
                        value
                    )

            logger.debug(
                f&#34;  -&gt; first_action_value_param: {first_action_value_param} &#34;
            )
            logger.debug(
                f&#34;  -&gt; second_action_value_param: {second_action_value_param} &#34;
            )

        logger.debug(
            f&#39;Build action object for: {imow_action} -&gt; &#34;{imow_action.value}&#34;&#39;
        )
        # Build other action values depending on given ACTION
        if (
            imow_action == IMowActions.START_MOWING_FROM_POINT
        ):  # Add the duration and startpoint parameter
            duration = (
                str(int(first_action_value_param) / 10)
                if first_action_value_param
                else 30 / 10
            )
            startpoint = (
                str(second_action_value_param)
                if second_action_value_param
                else &#34;0&#34;
            )

            action_value = f&#34;{mower_external_id},{duration},{startpoint}&#34;

        elif (
            imow_action == IMowActions.START_MOWING
        ):  # by start- and/or endtime
            starttime = (
                str(first_action_value_param)
                if first_action_value_param
                else datetime.now().strftime(&#34;%Y-%m-%d %H:%M&#34;)
            )
            endtime = (
                str(second_action_value_param)
                if second_action_value_param != &#34;&#34;
                else None
            )
            if endtime:
                action_value = f&#34;{mower_external_id},{starttime},{endtime}&#34;
            else:
                action_value = f&#34;{mower_external_id},{starttime}&#34;

        else:
            action_value = mower_external_id

        action_object = {
            &#34;actionName&#34;: imow_action.value,
            &#34;actionValue&#34;: action_value
            # &#34;0000000123456789,15,0&#34; &lt;MowerExternalId,DurationInMunitesDividedBy10,StartPoint&gt;
            # &#34;0000000123456789,15,0&#34; &lt;MowerExternalId,StartTime,EndTime&gt;
        }
        logger.debug(
            f&#34;Intent sent as request body to imow api for mower with identifier: &#39;{mower_name}/{mower_id}/{mower_external_id}&#39;&#34;
        )
        logger.info(f&#34;  {action_object}&#34;)

        payload = json.dumps(action_object)

        response = await self.api_request(url, &#34;POST&#34;, payload=payload)
        if response.ok:
            logger.debug(
                f&#34;Success: Created mower (extId:{mower_external_id}) ActionObject with contents:&#34;
            )
            logger.debug(f&#34; {action_object}&#34;)
            logger.debug(f&#34; -&gt; (HTTP Status {response.status})&#34;)
        else:
            logger.error(f&#34;No success with mower-action: {payload}&#34;)
        return response

    async def update_setting(self, mower_id, setting, new_value) -&gt; MowerState:
        mower_state = await self.receive_mower_by_id(mower_id)

        payload_fields = {
            &#34;id&#34;: mower_state.id,
            &#34;unitFormat&#34;: mower_state.unitFormat,
            &#34;name&#34;: mower_state.name,
            &#34;teamable&#34;: mower_state.teamable,
            &#34;accountId&#34;: mower_state.accountId,
            &#34;childLock&#34;: mower_state.childLock,
            &#34;corridorMode&#34;: mower_state.corridorMode,
            &#34;mappingIntelligentHomeDrive&#34;: mower_state.mappingIntelligentHomeDrive,
            &#34;rainSensorMode&#34;: mower_state.rainSensorMode,
            &#34;edgeMowingMode&#34;: mower_state.edgeMowingMode,
            &#34;asmEnabled&#34;: mower_state.asmEnabled,
            &#34;gpsProtectionEnabled&#34;: mower_state.gpsProtectionEnabled,
            &#34;automaticModeEnabled&#34;: mower_state.automaticModeEnabled,
            &#34;localTimezoneOffset&#34;: mower_state.localTimezoneOffset,
            &#34;mowingTimeManual&#34;: None,
            &#34;mowingTime&#34;: None,
            &#34;team&#34;: mower_state.team,
            &#34;timeZone&#34;: mower_state.timeZone,
        }
        if payload_fields[setting] != new_value:
            payload_fields[setting] = new_value
            headers = {
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0&#34;,
                &#34;Accept&#34;: &#34;application/json, text/plain, */*&#34;,
                &#34;Accept-Language&#34;: &#34;de,en-US;q=0.7,en;q=0.3&#34;,
                &#34;Content-Type&#34;: &#34;application/json&#34;,
                &#34;Origin&#34;: &#34;https://app.imow.stihl.com&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Referer&#34;: &#34;https://app.imow.stihl.com/&#34;,
                &#34;TE&#34;: &#34;Trailers&#34;,
            }
            response = await self.api_request(
                url=f&#34;{IMOW_API_URI}/mowers/{mower_state.id}/&#34;,
                method=&#34;PUT&#34;,
                payload=json.dumps(payload_fields, indent=2).encode(&#34;utf-8&#34;),
                headers=headers,
            )
            mower_state.replace_state(json.loads(await response.text()))
            return mower_state

        else:
            logger.info(f&#34;{setting} is already {new_value}.&#34;)
            return await self.receive_mower_by_id(mower_id)

    async def get_status_by_name(self, mower_name: str) -&gt; dict:
        logger.debug(f&#34;get_status_by_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                return mower.status
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def get_status_by_id(self, mower_id=(str, int)) -&gt; dict:
        if not type(mower_id) == str:
            mower_id = str(mower_id)
        logger.debug(f&#34;get_status_by_id: {mower_id}&#34;)
        try:
            response = await self.receive_mower_by_id(mower_id)
            return response.status
        except ConnectionError:
            raise LookupError(
                f&#34;Mower with id {mower_id} not found in upstream&#34;
            )

    async def get_status_by_action_id(self, mower_action_id: str) -&gt; dict:
        logger.debug(f&#34;get_status_by_action_id: {mower_action_id}&#34;)
        for mower in await self.receive_mowers():
            if mower.externalId == mower_action_id:
                return mower.status
        raise LookupError(
            f&#34;Mower with externalId {mower_action_id} not found in upstream&#34;
        )

    async def get_mower_action_id_from_name(self, mower_name: str) -&gt; str:
        logger.debug(f&#34;get_mower_action_id_from_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                return mower.externalId
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def get_mower_action_id_from_id(self, mower_id: str) -&gt; str:
        logger.debug(f&#34;get_mower_action_id_from_id: {mower_id}&#34;)
        try:
            response = await self.receive_mower_by_id(mower_id)
            logger.debug(f&#34; - {response.externalId}&#34;)
            return response.externalId
        except ConnectionError:
            raise LookupError(
                f&#34;Mower with id {mower_id} not found in upstream&#34;
            )

    async def get_mower_id_from_name(self, mower_name: str) -&gt; str:
        logger.debug(f&#34;get_mower_id_from_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                return mower.id
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def receive_mowers(self) -&gt; List[MowerState]:
        logger.debug(&#34;receive_mowers: &#34;)
        mowers = []
        response = await self.api_request(f&#34;{IMOW_API_URI}/mowers/&#34;, &#34;GET&#34;)
        for mower in json.loads(await response.text()):
            mowers.append(MowerState(mower, self))
        for mower in mowers:
            logger.debug(f&#34;  - {mower.name}&#34;)
        return mowers

    async def receive_mower_by_name(self, mower_name: str) -&gt; MowerState:
        logger.debug(f&#34;get_mower_from_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                logger.debug(mower)
                return mower
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def receive_mower_by_id(self, mower_id: str) -&gt; MowerState:
        logger.debug(f&#34;receive_mower: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/&#34;, &#34;GET&#34;
        )
        mower = MowerState(json.loads(await response.text()), self)
        logger.debug(mower)
        return mower

    async def receive_mower_statistics(self, mower_id: str) -&gt; dict:
        logger.debug(f&#34;receive_mower_statistics: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/statistic/&#34;, &#34;GET&#34;
        )
        stats = json.loads(await response.text())
        logger.debug(stats)
        return stats

    async def receive_mower_week_mow_time_in_hours(
        self, mower_id: str
    ) -&gt; dict:
        logger.debug(f&#34;receive_mower_week_mow_time_in_hours: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/statistics/week-mow-time-in-hours/&#34;,
            &#34;GET&#34;,
        )
        mow_times = json.loads(await response.text())
        logger.debug(mow_times)
        return mow_times

    async def receive_mower_start_points(self, mower_id: str) -&gt; dict:
        logger.debug(f&#34;receive_mower_start_points: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/start-points/&#34;, &#34;GET&#34;
        )
        start_points = json.loads(await response.text())
        for startpoint in start_points:
            logger.debug(f&#34;  - {startpoint}&#34;)
        return start_points</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="imow.api.IMowApi"><code class="flex name class">
<span>class <span class="ident">IMowApi</span></span>
<span>(</span><span>email: str = None, password: str = None, token: str = None, aiohttp_session: ClientSession = None, lang: str = 'en')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IMowApi:
    def __init__(
        self,
        email: str = None,
        password: str = None,
        token: str = None,
        aiohttp_session: ClientSession = None,
        lang: str = &#34;en&#34;,
    ) -&gt; None:
        self.http_session: ClientSession = aiohttp_session
        self.csrf_token: str = &#34;&#34;
        self.requestId: str = &#34;&#34;
        self.access_token: str = token
        self.token_expires: datetime = None
        self.api_email: str = email
        self.api_password: str = password
        self.lang = lang
        self.messages_user = None
        self.messages_en = None

    async def close(self):
        &#34;&#34;&#34;Cleanup the aiohttp Session&#34;&#34;&#34;
        await asyncio.sleep(0.250)
        await self.http_session.close()

    async def check_api_maintenance(self) -&gt; None:
        url = &#34;https://app-api-maintenance-r-euwe-4bf2d8.azurewebsites.net/maintenance/&#34;

        headers = {
            &#34;Authorization&#34;: &#34;&#34;,
        }
        response = await self.api_request(url, &#34;GET&#34;, headers=headers)
        status = json.loads(await response.text())
        logger.debug(status)
        if status[&#34;serverDisrupted&#34;] or status[&#34;serverDown&#34;]:
            msg = (
                f&#34;iMow API is under Maintenance -&gt; &#34;
                f&#39;serverDisrupted: {status[&#34;serverDisrupted&#34;]}, serverDown: {status[&#34;serverDown&#34;]}, &#39;
                f&#39;affectedTill {status[&#34;affectedTill&#34;]}&#39;
            )
            raise ApiMaintenanceError(msg)

    async def get_token(
        self,
        email: str = &#34;&#34;,
        password: str = &#34;&#34;,
        force_reauth=False,
        return_expire_time=False,
    ) -&gt; Union[Tuple[str, datetime], str]:
        &#34;&#34;&#34;
        look for a token, if present, return. Else authenticate and store new token
        :param return_expire_time:
        :param email: stihl webapp login email non-url-encoded
        :param password: stihl webapp login password
        :param force_reauth: Force a re-authentication with username and password
        :return: tuple, the access token and a datetime object containing the expire date
        &#34;&#34;&#34;

        if not self.access_token or force_reauth:
            if email and password:
                self.api_password = password
                self.api_email = email
            if force_reauth:
                await self.api_logout()
                self.csrf_token = &#34;&#34;
                self.requestId = &#34;&#34;
                self.access_token: str = &#34;&#34;
                self.token_expires: datetime = None
            if not self.api_email and not self.api_password:
                raise LoginError(
                    &#34;Got no credentials to authenticate, please provide&#34;
                )
            await self.__authenticate(self.api_email, self.api_password)
            logger.debug(&#34;Get Token: Re-Authenticate&#34;)

        await self.validate_token()
        if return_expire_time:
            return self.access_token, self.token_expires
        else:
            return self.access_token

    async def api_logout(self):
        if not self.http_session or self.http_session.closed:
            self.http_session = aiohttp.ClientSession(raise_for_status=True)
        async with self.http_session.post(
            &#34;https://oauth2.imow.stihl.com/authentication/logout/&#34;,
            data={
                &#34;csrf-token&#34;: self.csrf_token,
                &#34;logoutUrl&#34;: &#34;https://app.imow.stihl.com&#34;,
                &#34;clientId&#34;: &#34;9526273B-1477-47C6-801C-4356F58EF883&#34;,
                &#34;cancelUrl&#34;: &#34;https://app.imow.stihl.com&#34;,
            },
        ) as resp:
            await resp.read()
        self.http_session.cookie_jar.clear_domain(&#34;https://app.imow.stihl.com&#34;)
        self.http_session.cookie_jar.clear_domain(
            &#34;https://oauth2.imow.stihl.com/&#34;
        )

    async def validate_token(self, explicit_token: str = None) -&gt; bool:
        old_token = None
        if explicit_token:
            # save old instance token and place temp token for validation
            old_token = self.access_token
            self.access_token = explicit_token

        await self.receive_mowers()

        if explicit_token:
            # Reset instance token
            self.access_token = old_token
        return True

    async def __authenticate(
        self, email: str, password: str
    ) -&gt; List[str, str, aiohttp.ClientResponse]:
        &#34;&#34;&#34;
        try the authentication request with fetched csrf and requestId payload
        :param email: stihl webapp login email non-url-encoded
        :param password: stihl webapp login password
        :return: the newly created access token, and expire time besides the legacy response
        &#34;&#34;&#34;

        await self.__fetch_new_csrf_token_and_request_id()
        url = f&#34;{IMOW_OAUTH_URI}/authentication/authenticate/?lang={self.lang}&#34;
        encoded_mail = quote(email)
        encoded_password = quote(password)
        payload = (
            f&#34;mail={encoded_mail}&amp;password={encoded_password}&#34;
            f&#34;&amp;csrf-token={self.csrf_token}&amp;requestId={self.requestId} &#34;
        )
        headers = {
            &#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded&#34;,
        }
        response = await self.api_request(
            url, &#34;POST&#34;, payload=payload, headers=headers
        )

        response_url_query_args = furl(response.real_url).fragment.args
        if &#34;access_token&#34; not in response_url_query_args:
            raise LoginError(
                &#34;STIHL iMow did not return an access_token, check your credentials&#34;
            )

        self.access_token = response_url_query_args[&#34;access_token&#34;]
        self.token_expires = datetime.now() + timedelta(
            seconds=int(response_url_query_args[&#34;expires_in&#34;])
        )
        return self.access_token, self.token_expires, response

    async def __fetch_new_csrf_token_and_request_id(self) -&gt; List[str, str]:
        &#34;&#34;&#34;
        Fetch a new csrf_token and requestId to do the authentication as expected by the api
        csrf_token and requestId are used as payload within authentication
        &#34;&#34;&#34;

        # URL needs whole redirect query parameter
        url = (
            f&#34;{IMOW_OAUTH_URI}/authentication/?lang=de_DE&amp;authorizationRedirectUrl=https%3A%2F%2Foauth2&#34;
            &#34;.imow.stihl.com%2Fauthorization%2F%3Fresponse_type%3Dtoken%26client_id%3D9526273B-1477-47C6-801C&#34;
            &#34;-4356F58EF883%26redirect_uri%3Dhttps%253A%252F%252Fapp.imow.stihl.com%252F%2523%252Fauthorize%26state&#34;
        )
        response = await self.api_request(url, &#34;GET&#34;)

        soup = BeautifulSoup(await response.text(), &#34;html.parser&#34;)
        try:
            upstream_csrf_token = soup.find(
                &#34;input&#34;, {&#34;name&#34;: &#34;csrf-token&#34;}
            ).get(&#34;value&#34;)
            upstream_request_id = soup.find(
                &#34;input&#34;, {&#34;name&#34;: &#34;requestId&#34;}
            ).get(&#34;value&#34;)
        except AttributeError:
            raise ProcessLookupError(
                &#34;Did not find necessary csrf token and/or request id in html source&#34;
            )

        self.csrf_token = upstream_csrf_token
        self.requestId = upstream_request_id
        logger.debug(&#34;CSRF: new token and request id &lt;redacted&gt;&#34;)
        return self.csrf_token, self.requestId

    async def fetch_messages(self):
        try:
            url_en = (
                &#34;https://app.imow.stihl.com/assets/i18n/animations/en.json&#34;
            )
            async with self.http_session.request(&#34;GET&#34;, url_en) as response_en:
                i18n_en = json.loads(await response_en.text())
            self.messages_en = Messages(i18n_en)
            if self.lang != &#34;en&#34;:
                url_user = f&#34;https://app.imow.stihl.com/assets/i18n/animations/{self.lang}.json&#34;
                async with self.http_session.request(
                    &#34;GET&#34;, url_user
                ) as response_user:
                    i18n_user = json.loads(await response_user.text())
                    self.messages_user = Messages(i18n_user)
            else:
                self.messages_user = self.messages_en

        except ClientResponseError as e:
            if e.status == 404:
                raise LanguageNotFoundError(
                    f&#34;Language-File &#39;{self.lang}.json&#39; not found on imow upstream (&#34;
                    f&#34;https://app.imow.stihl.com/assets/i18n/animations/{self.lang}.json)&#34;
                )

    async def api_request(
        self, url, method, payload=None, headers=None
    ) -&gt; aiohttp.ClientResponse:
        &#34;&#34;&#34;
        Do a standardized request against the stihl imow webapi, with predefined headers
        :param url: The target URL
        :param method: The Method to use
        :param payload: optional payload
        :param headers: optional update headers
        :return: the aiohttp.ClientResponse
        &#34;&#34;&#34;
        if not self.http_session or self.http_session.closed:
            self.http_session = aiohttp.ClientSession(raise_for_status=True)
        if not self.messages_en:
            await self.fetch_messages()
        if (
            self.token_expires
            and (self.token_expires - datetime.now()).days &lt;= 1
        ):
            logger.info(
                &#34;Fetching new access_token because old one expires in less than 1 day&#34;
            )
            await self.get_token(force_reauth=True)

        if not payload:
            payload = {}

        headers_obj = {
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0&#34;,
            &#34;Accept&#34;: &#34;application/json, text/plain, */*&#34;,
            &#34;Accept-Language&#34;: &#34;de,en-US;q=0.7,en;q=0.3&#34;,
            &#34;Authorization&#34;: f&#39;Bearer {self.access_token if self.access_token else &#34;&#34;}&#39;,
            &#34;Origin&#34;: &#34;https://app.imow.stihl.com&#34;,
            &#34;DNT&#34;: &#34;1&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Referer&#34;: &#34;https://app.imow.stihl.com/&#34;,
            &#34;Pragma&#34;: &#34;no-cache&#34;,
            &#34;Cache-Control&#34;: &#34;no-cache&#34;,
            &#34;TE&#34;: &#34;Trailers&#34;,
            &#34;Content-Type&#34;: &#34;application/json&#34;,
        }
        if headers:
            headers_obj.update(headers)
        try:
            async with self.http_session.request(
                method, url, headers=headers_obj, data=payload
            ) as response:
                await response.read()
                response.raise_for_status()
                return response
        except ClientResponseError as e:
            if e.status == 500:
                await self.check_api_maintenance()
            raise e

    def validate_and_fix_datetime(self, value) -&gt; str:
        &#34;&#34;&#34;
        Try to convert and validate the given string from &#34;%Y-%m-%d %H:%M&#34; or &#34;%Y-%m-%d %H:%M:%S into a datetime object and give the needed &#34;%Y-%m-%d %H:%M&#34; string back.
        :param value: the string tobe checked
        :return: the correctly formated string
        &#34;&#34;&#34;
        try:
            datetime_object = datetime.strptime(value, &#34;%Y-%m-%d %H:%M&#34;)
            return datetime_object.strftime(&#34;%Y-%m-%d %H:%M&#34;)
        except ValueError as ve:
            logger.warn(
                f&#34;  Try fixing given time format because {ve} in {value}&#34;
            )
            try:
                datetime_object = datetime.strptime(value, &#34;%Y-%m-%d %H:%M:%S&#34;)
                return datetime_object.strftime(&#34;%Y-%m-%d %H:%M&#34;)
            except ValueError as ve2:
                raise ValueError(
                    f&#39;Unsupported &#34;time&#34; argument: {value} -&gt; {ve2}&#39;
                )

    async def intent(
        self,
        imow_action: IMowActions,
        mower_name: str = &#34;&#34;,
        mower_id: str = &#34;&#34;,
        mower_external_id: str = &#34;&#34;,
        first_action_value_param: any = &#34;&#34;,
        second_action_value_param: any = &#34;&#34;,
        **kwargs,
    ) -&gt; aiohttp.ClientResponse:
        &#34;&#34;&#34;
        Intent to do a action. This seems to create a job object upstream. The action object contains an action Enum,
        the action Value is &lt;MowerExternalId&gt; or &lt;MowerExternalId,DurationInMunitesDividedBy10,StartPoint&gt; if
        startMowing is chosen

        :param imow_action: Anything from imow.common.actions
        :param mower_name: sth to identify which mower is used
        :param mower_id: sth to identify which mower is used
        :param mower_external_id:
            necessary identifier for the mowers for actions.
            This is looked up, if only mower_name or mower_id is provided

        :param first_action_value_param: first argument passed into the action call request to the api. Can be one of the following contents:
            A duration: minutes of intented mowing. Used by START_MOWING_FROM_POINT. Defaults to &#39;30&#39; minutes.
            A starttime: a datetime when to start mowing. I.e. &#39;2023-08-12 20:50&#39; used by START_MOWING

        :param second_action_value_param: second argument passed into the action call request to the api. Can be one of the following contents:
            A startpoint: from which the mowing shall start. Used by START_MOWING_FROM_POINT. Defaults to &#39;0&#39;.
            An endtime: a datetime when to stop mowing. I.e. &#39;2023-08-12 20:50&#39; used by START_MOWING
        :return:
        &#34;&#34;&#34;
        if not mower_external_id and not mower_id and not mower_name:
            raise AttributeError(
                &#34;Need some mower to work on. Please specify mower_[name|id|action_id]&#34;
            )
        if not mower_external_id and mower_name:
            mower_external_id = await self.get_mower_action_id_from_name(
                mower_name
            )
        if not mower_external_id and mower_id:
            mower_external_id = await self.get_mower_action_id_from_id(
                mower_id
            )

        if len(mower_external_id) &lt; 16:
            raise AttributeError(
                f&#34;Invalid mower_action_id, need exactly 16 chars, got {len(mower_external_id)} in {mower_external_id}&#34;
            )

        url = f&#34;{IMOW_API_URI}/mower-actions/&#34;

        given_kwargs = kwargs.items()
        if len(given_kwargs) &gt; 0:
            logger.debug(
                &#34;Translating given intent **kwargs to action_value_param&#34;
            )
            for key, value in given_kwargs:
                logger.debug(&#34;  {0} = {1}&#34;.format(key, value))
                if key == &#34;duration&#34;:
                    first_action_value_param = value
                if key == &#34;startpoint&#34;:
                    second_action_value_param = value

                if key == &#34;starttime&#34;:
                    first_action_value_param = self.validate_and_fix_datetime(
                        value
                    )
                if key == &#34;endtime&#34;:
                    second_action_value_param = self.validate_and_fix_datetime(
                        value
                    )

            logger.debug(
                f&#34;  -&gt; first_action_value_param: {first_action_value_param} &#34;
            )
            logger.debug(
                f&#34;  -&gt; second_action_value_param: {second_action_value_param} &#34;
            )

        logger.debug(
            f&#39;Build action object for: {imow_action} -&gt; &#34;{imow_action.value}&#34;&#39;
        )
        # Build other action values depending on given ACTION
        if (
            imow_action == IMowActions.START_MOWING_FROM_POINT
        ):  # Add the duration and startpoint parameter
            duration = (
                str(int(first_action_value_param) / 10)
                if first_action_value_param
                else 30 / 10
            )
            startpoint = (
                str(second_action_value_param)
                if second_action_value_param
                else &#34;0&#34;
            )

            action_value = f&#34;{mower_external_id},{duration},{startpoint}&#34;

        elif (
            imow_action == IMowActions.START_MOWING
        ):  # by start- and/or endtime
            starttime = (
                str(first_action_value_param)
                if first_action_value_param
                else datetime.now().strftime(&#34;%Y-%m-%d %H:%M&#34;)
            )
            endtime = (
                str(second_action_value_param)
                if second_action_value_param != &#34;&#34;
                else None
            )
            if endtime:
                action_value = f&#34;{mower_external_id},{starttime},{endtime}&#34;
            else:
                action_value = f&#34;{mower_external_id},{starttime}&#34;

        else:
            action_value = mower_external_id

        action_object = {
            &#34;actionName&#34;: imow_action.value,
            &#34;actionValue&#34;: action_value
            # &#34;0000000123456789,15,0&#34; &lt;MowerExternalId,DurationInMunitesDividedBy10,StartPoint&gt;
            # &#34;0000000123456789,15,0&#34; &lt;MowerExternalId,StartTime,EndTime&gt;
        }
        logger.debug(
            f&#34;Intent sent as request body to imow api for mower with identifier: &#39;{mower_name}/{mower_id}/{mower_external_id}&#39;&#34;
        )
        logger.info(f&#34;  {action_object}&#34;)

        payload = json.dumps(action_object)

        response = await self.api_request(url, &#34;POST&#34;, payload=payload)
        if response.ok:
            logger.debug(
                f&#34;Success: Created mower (extId:{mower_external_id}) ActionObject with contents:&#34;
            )
            logger.debug(f&#34; {action_object}&#34;)
            logger.debug(f&#34; -&gt; (HTTP Status {response.status})&#34;)
        else:
            logger.error(f&#34;No success with mower-action: {payload}&#34;)
        return response

    async def update_setting(self, mower_id, setting, new_value) -&gt; MowerState:
        mower_state = await self.receive_mower_by_id(mower_id)

        payload_fields = {
            &#34;id&#34;: mower_state.id,
            &#34;unitFormat&#34;: mower_state.unitFormat,
            &#34;name&#34;: mower_state.name,
            &#34;teamable&#34;: mower_state.teamable,
            &#34;accountId&#34;: mower_state.accountId,
            &#34;childLock&#34;: mower_state.childLock,
            &#34;corridorMode&#34;: mower_state.corridorMode,
            &#34;mappingIntelligentHomeDrive&#34;: mower_state.mappingIntelligentHomeDrive,
            &#34;rainSensorMode&#34;: mower_state.rainSensorMode,
            &#34;edgeMowingMode&#34;: mower_state.edgeMowingMode,
            &#34;asmEnabled&#34;: mower_state.asmEnabled,
            &#34;gpsProtectionEnabled&#34;: mower_state.gpsProtectionEnabled,
            &#34;automaticModeEnabled&#34;: mower_state.automaticModeEnabled,
            &#34;localTimezoneOffset&#34;: mower_state.localTimezoneOffset,
            &#34;mowingTimeManual&#34;: None,
            &#34;mowingTime&#34;: None,
            &#34;team&#34;: mower_state.team,
            &#34;timeZone&#34;: mower_state.timeZone,
        }
        if payload_fields[setting] != new_value:
            payload_fields[setting] = new_value
            headers = {
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0&#34;,
                &#34;Accept&#34;: &#34;application/json, text/plain, */*&#34;,
                &#34;Accept-Language&#34;: &#34;de,en-US;q=0.7,en;q=0.3&#34;,
                &#34;Content-Type&#34;: &#34;application/json&#34;,
                &#34;Origin&#34;: &#34;https://app.imow.stihl.com&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Referer&#34;: &#34;https://app.imow.stihl.com/&#34;,
                &#34;TE&#34;: &#34;Trailers&#34;,
            }
            response = await self.api_request(
                url=f&#34;{IMOW_API_URI}/mowers/{mower_state.id}/&#34;,
                method=&#34;PUT&#34;,
                payload=json.dumps(payload_fields, indent=2).encode(&#34;utf-8&#34;),
                headers=headers,
            )
            mower_state.replace_state(json.loads(await response.text()))
            return mower_state

        else:
            logger.info(f&#34;{setting} is already {new_value}.&#34;)
            return await self.receive_mower_by_id(mower_id)

    async def get_status_by_name(self, mower_name: str) -&gt; dict:
        logger.debug(f&#34;get_status_by_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                return mower.status
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def get_status_by_id(self, mower_id=(str, int)) -&gt; dict:
        if not type(mower_id) == str:
            mower_id = str(mower_id)
        logger.debug(f&#34;get_status_by_id: {mower_id}&#34;)
        try:
            response = await self.receive_mower_by_id(mower_id)
            return response.status
        except ConnectionError:
            raise LookupError(
                f&#34;Mower with id {mower_id} not found in upstream&#34;
            )

    async def get_status_by_action_id(self, mower_action_id: str) -&gt; dict:
        logger.debug(f&#34;get_status_by_action_id: {mower_action_id}&#34;)
        for mower in await self.receive_mowers():
            if mower.externalId == mower_action_id:
                return mower.status
        raise LookupError(
            f&#34;Mower with externalId {mower_action_id} not found in upstream&#34;
        )

    async def get_mower_action_id_from_name(self, mower_name: str) -&gt; str:
        logger.debug(f&#34;get_mower_action_id_from_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                return mower.externalId
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def get_mower_action_id_from_id(self, mower_id: str) -&gt; str:
        logger.debug(f&#34;get_mower_action_id_from_id: {mower_id}&#34;)
        try:
            response = await self.receive_mower_by_id(mower_id)
            logger.debug(f&#34; - {response.externalId}&#34;)
            return response.externalId
        except ConnectionError:
            raise LookupError(
                f&#34;Mower with id {mower_id} not found in upstream&#34;
            )

    async def get_mower_id_from_name(self, mower_name: str) -&gt; str:
        logger.debug(f&#34;get_mower_id_from_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                return mower.id
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def receive_mowers(self) -&gt; List[MowerState]:
        logger.debug(&#34;receive_mowers: &#34;)
        mowers = []
        response = await self.api_request(f&#34;{IMOW_API_URI}/mowers/&#34;, &#34;GET&#34;)
        for mower in json.loads(await response.text()):
            mowers.append(MowerState(mower, self))
        for mower in mowers:
            logger.debug(f&#34;  - {mower.name}&#34;)
        return mowers

    async def receive_mower_by_name(self, mower_name: str) -&gt; MowerState:
        logger.debug(f&#34;get_mower_from_name: {mower_name}&#34;)
        for mower in await self.receive_mowers():
            if mower.name == mower_name:
                logger.debug(mower)
                return mower
        raise LookupError(
            f&#34;Mower with name {mower_name} not found in upstream&#34;
        )

    async def receive_mower_by_id(self, mower_id: str) -&gt; MowerState:
        logger.debug(f&#34;receive_mower: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/&#34;, &#34;GET&#34;
        )
        mower = MowerState(json.loads(await response.text()), self)
        logger.debug(mower)
        return mower

    async def receive_mower_statistics(self, mower_id: str) -&gt; dict:
        logger.debug(f&#34;receive_mower_statistics: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/statistic/&#34;, &#34;GET&#34;
        )
        stats = json.loads(await response.text())
        logger.debug(stats)
        return stats

    async def receive_mower_week_mow_time_in_hours(
        self, mower_id: str
    ) -&gt; dict:
        logger.debug(f&#34;receive_mower_week_mow_time_in_hours: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/statistics/week-mow-time-in-hours/&#34;,
            &#34;GET&#34;,
        )
        mow_times = json.loads(await response.text())
        logger.debug(mow_times)
        return mow_times

    async def receive_mower_start_points(self, mower_id: str) -&gt; dict:
        logger.debug(f&#34;receive_mower_start_points: {mower_id}&#34;)
        response = await self.api_request(
            f&#34;{IMOW_API_URI}/mowers/{mower_id}/start-points/&#34;, &#34;GET&#34;
        )
        start_points = json.loads(await response.text())
        for startpoint in start_points:
            logger.debug(f&#34;  - {startpoint}&#34;)
        return start_points</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="imow.api.IMowApi.api_logout"><code class="name flex">
<span>async def <span class="ident">api_logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def api_logout(self):
    if not self.http_session or self.http_session.closed:
        self.http_session = aiohttp.ClientSession(raise_for_status=True)
    async with self.http_session.post(
        &#34;https://oauth2.imow.stihl.com/authentication/logout/&#34;,
        data={
            &#34;csrf-token&#34;: self.csrf_token,
            &#34;logoutUrl&#34;: &#34;https://app.imow.stihl.com&#34;,
            &#34;clientId&#34;: &#34;9526273B-1477-47C6-801C-4356F58EF883&#34;,
            &#34;cancelUrl&#34;: &#34;https://app.imow.stihl.com&#34;,
        },
    ) as resp:
        await resp.read()
    self.http_session.cookie_jar.clear_domain(&#34;https://app.imow.stihl.com&#34;)
    self.http_session.cookie_jar.clear_domain(
        &#34;https://oauth2.imow.stihl.com/&#34;
    )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.api_request"><code class="name flex">
<span>async def <span class="ident">api_request</span></span>(<span>self, url, method, payload=None, headers=None) ‑> aiohttp.client_reqrep.ClientResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Do a standardized request against the stihl imow webapi, with predefined headers
:param url: The target URL
:param method: The Method to use
:param payload: optional payload
:param headers: optional update headers
:return: the aiohttp.ClientResponse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def api_request(
    self, url, method, payload=None, headers=None
) -&gt; aiohttp.ClientResponse:
    &#34;&#34;&#34;
    Do a standardized request against the stihl imow webapi, with predefined headers
    :param url: The target URL
    :param method: The Method to use
    :param payload: optional payload
    :param headers: optional update headers
    :return: the aiohttp.ClientResponse
    &#34;&#34;&#34;
    if not self.http_session or self.http_session.closed:
        self.http_session = aiohttp.ClientSession(raise_for_status=True)
    if not self.messages_en:
        await self.fetch_messages()
    if (
        self.token_expires
        and (self.token_expires - datetime.now()).days &lt;= 1
    ):
        logger.info(
            &#34;Fetching new access_token because old one expires in less than 1 day&#34;
        )
        await self.get_token(force_reauth=True)

    if not payload:
        payload = {}

    headers_obj = {
        &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0&#34;,
        &#34;Accept&#34;: &#34;application/json, text/plain, */*&#34;,
        &#34;Accept-Language&#34;: &#34;de,en-US;q=0.7,en;q=0.3&#34;,
        &#34;Authorization&#34;: f&#39;Bearer {self.access_token if self.access_token else &#34;&#34;}&#39;,
        &#34;Origin&#34;: &#34;https://app.imow.stihl.com&#34;,
        &#34;DNT&#34;: &#34;1&#34;,
        &#34;Connection&#34;: &#34;keep-alive&#34;,
        &#34;Referer&#34;: &#34;https://app.imow.stihl.com/&#34;,
        &#34;Pragma&#34;: &#34;no-cache&#34;,
        &#34;Cache-Control&#34;: &#34;no-cache&#34;,
        &#34;TE&#34;: &#34;Trailers&#34;,
        &#34;Content-Type&#34;: &#34;application/json&#34;,
    }
    if headers:
        headers_obj.update(headers)
    try:
        async with self.http_session.request(
            method, url, headers=headers_obj, data=payload
        ) as response:
            await response.read()
            response.raise_for_status()
            return response
    except ClientResponseError as e:
        if e.status == 500:
            await self.check_api_maintenance()
        raise e</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.check_api_maintenance"><code class="name flex">
<span>async def <span class="ident">check_api_maintenance</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_api_maintenance(self) -&gt; None:
    url = &#34;https://app-api-maintenance-r-euwe-4bf2d8.azurewebsites.net/maintenance/&#34;

    headers = {
        &#34;Authorization&#34;: &#34;&#34;,
    }
    response = await self.api_request(url, &#34;GET&#34;, headers=headers)
    status = json.loads(await response.text())
    logger.debug(status)
    if status[&#34;serverDisrupted&#34;] or status[&#34;serverDown&#34;]:
        msg = (
            f&#34;iMow API is under Maintenance -&gt; &#34;
            f&#39;serverDisrupted: {status[&#34;serverDisrupted&#34;]}, serverDown: {status[&#34;serverDown&#34;]}, &#39;
            f&#39;affectedTill {status[&#34;affectedTill&#34;]}&#39;
        )
        raise ApiMaintenanceError(msg)</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleanup the aiohttp Session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    &#34;&#34;&#34;Cleanup the aiohttp Session&#34;&#34;&#34;
    await asyncio.sleep(0.250)
    await self.http_session.close()</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.fetch_messages"><code class="name flex">
<span>async def <span class="ident">fetch_messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_messages(self):
    try:
        url_en = (
            &#34;https://app.imow.stihl.com/assets/i18n/animations/en.json&#34;
        )
        async with self.http_session.request(&#34;GET&#34;, url_en) as response_en:
            i18n_en = json.loads(await response_en.text())
        self.messages_en = Messages(i18n_en)
        if self.lang != &#34;en&#34;:
            url_user = f&#34;https://app.imow.stihl.com/assets/i18n/animations/{self.lang}.json&#34;
            async with self.http_session.request(
                &#34;GET&#34;, url_user
            ) as response_user:
                i18n_user = json.loads(await response_user.text())
                self.messages_user = Messages(i18n_user)
        else:
            self.messages_user = self.messages_en

    except ClientResponseError as e:
        if e.status == 404:
            raise LanguageNotFoundError(
                f&#34;Language-File &#39;{self.lang}.json&#39; not found on imow upstream (&#34;
                f&#34;https://app.imow.stihl.com/assets/i18n/animations/{self.lang}.json)&#34;
            )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_mower_action_id_from_id"><code class="name flex">
<span>async def <span class="ident">get_mower_action_id_from_id</span></span>(<span>self, mower_id: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_mower_action_id_from_id(self, mower_id: str) -&gt; str:
    logger.debug(f&#34;get_mower_action_id_from_id: {mower_id}&#34;)
    try:
        response = await self.receive_mower_by_id(mower_id)
        logger.debug(f&#34; - {response.externalId}&#34;)
        return response.externalId
    except ConnectionError:
        raise LookupError(
            f&#34;Mower with id {mower_id} not found in upstream&#34;
        )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_mower_action_id_from_name"><code class="name flex">
<span>async def <span class="ident">get_mower_action_id_from_name</span></span>(<span>self, mower_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_mower_action_id_from_name(self, mower_name: str) -&gt; str:
    logger.debug(f&#34;get_mower_action_id_from_name: {mower_name}&#34;)
    for mower in await self.receive_mowers():
        if mower.name == mower_name:
            return mower.externalId
    raise LookupError(
        f&#34;Mower with name {mower_name} not found in upstream&#34;
    )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_mower_id_from_name"><code class="name flex">
<span>async def <span class="ident">get_mower_id_from_name</span></span>(<span>self, mower_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_mower_id_from_name(self, mower_name: str) -&gt; str:
    logger.debug(f&#34;get_mower_id_from_name: {mower_name}&#34;)
    for mower in await self.receive_mowers():
        if mower.name == mower_name:
            return mower.id
    raise LookupError(
        f&#34;Mower with name {mower_name} not found in upstream&#34;
    )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_status_by_action_id"><code class="name flex">
<span>async def <span class="ident">get_status_by_action_id</span></span>(<span>self, mower_action_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_status_by_action_id(self, mower_action_id: str) -&gt; dict:
    logger.debug(f&#34;get_status_by_action_id: {mower_action_id}&#34;)
    for mower in await self.receive_mowers():
        if mower.externalId == mower_action_id:
            return mower.status
    raise LookupError(
        f&#34;Mower with externalId {mower_action_id} not found in upstream&#34;
    )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_status_by_id"><code class="name flex">
<span>async def <span class="ident">get_status_by_id</span></span>(<span>self, mower_id=(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;)) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_status_by_id(self, mower_id=(str, int)) -&gt; dict:
    if not type(mower_id) == str:
        mower_id = str(mower_id)
    logger.debug(f&#34;get_status_by_id: {mower_id}&#34;)
    try:
        response = await self.receive_mower_by_id(mower_id)
        return response.status
    except ConnectionError:
        raise LookupError(
            f&#34;Mower with id {mower_id} not found in upstream&#34;
        )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_status_by_name"><code class="name flex">
<span>async def <span class="ident">get_status_by_name</span></span>(<span>self, mower_name: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_status_by_name(self, mower_name: str) -&gt; dict:
    logger.debug(f&#34;get_status_by_name: {mower_name}&#34;)
    for mower in await self.receive_mowers():
        if mower.name == mower_name:
            return mower.status
    raise LookupError(
        f&#34;Mower with name {mower_name} not found in upstream&#34;
    )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.get_token"><code class="name flex">
<span>async def <span class="ident">get_token</span></span>(<span>self, email: str = '', password: str = '', force_reauth=False, return_expire_time=False) ‑> Union[Tuple[str, datetime.datetime], str]</span>
</code></dt>
<dd>
<div class="desc"><p>look for a token, if present, return. Else authenticate and store new token
:param return_expire_time:
:param email: stihl webapp login email non-url-encoded
:param password: stihl webapp login password
:param force_reauth: Force a re-authentication with username and password
:return: tuple, the access token and a datetime object containing the expire date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_token(
    self,
    email: str = &#34;&#34;,
    password: str = &#34;&#34;,
    force_reauth=False,
    return_expire_time=False,
) -&gt; Union[Tuple[str, datetime], str]:
    &#34;&#34;&#34;
    look for a token, if present, return. Else authenticate and store new token
    :param return_expire_time:
    :param email: stihl webapp login email non-url-encoded
    :param password: stihl webapp login password
    :param force_reauth: Force a re-authentication with username and password
    :return: tuple, the access token and a datetime object containing the expire date
    &#34;&#34;&#34;

    if not self.access_token or force_reauth:
        if email and password:
            self.api_password = password
            self.api_email = email
        if force_reauth:
            await self.api_logout()
            self.csrf_token = &#34;&#34;
            self.requestId = &#34;&#34;
            self.access_token: str = &#34;&#34;
            self.token_expires: datetime = None
        if not self.api_email and not self.api_password:
            raise LoginError(
                &#34;Got no credentials to authenticate, please provide&#34;
            )
        await self.__authenticate(self.api_email, self.api_password)
        logger.debug(&#34;Get Token: Re-Authenticate&#34;)

    await self.validate_token()
    if return_expire_time:
        return self.access_token, self.token_expires
    else:
        return self.access_token</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.intent"><code class="name flex">
<span>async def <span class="ident">intent</span></span>(<span>self, imow_action: IMowActions, mower_name: str = '', mower_id: str = '', mower_external_id: str = '', first_action_value_param: any = '', second_action_value_param: any = '', **kwargs) ‑> aiohttp.client_reqrep.ClientResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Intent to do a action. This seems to create a job object upstream. The action object contains an action Enum,
the action Value is <MowerExternalId> or <MowerExternalId,DurationInMunitesDividedBy10,StartPoint> if
startMowing is chosen</p>
<p>:param imow_action: Anything from imow.common.actions
:param mower_name: sth to identify which mower is used
:param mower_id: sth to identify which mower is used
:param mower_external_id:
necessary identifier for the mowers for actions.
This is looked up, if only mower_name or mower_id is provided</p>
<p>:param first_action_value_param: first argument passed into the action call request to the api. Can be one of the following contents:
A duration: minutes of intented mowing. Used by START_MOWING_FROM_POINT. Defaults to '30' minutes.
A starttime: a datetime when to start mowing. I.e. '2023-08-12 20:50' used by START_MOWING</p>
<p>:param second_action_value_param: second argument passed into the action call request to the api. Can be one of the following contents:
A startpoint: from which the mowing shall start. Used by START_MOWING_FROM_POINT. Defaults to '0'.
An endtime: a datetime when to stop mowing. I.e. '2023-08-12 20:50' used by START_MOWING
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def intent(
    self,
    imow_action: IMowActions,
    mower_name: str = &#34;&#34;,
    mower_id: str = &#34;&#34;,
    mower_external_id: str = &#34;&#34;,
    first_action_value_param: any = &#34;&#34;,
    second_action_value_param: any = &#34;&#34;,
    **kwargs,
) -&gt; aiohttp.ClientResponse:
    &#34;&#34;&#34;
    Intent to do a action. This seems to create a job object upstream. The action object contains an action Enum,
    the action Value is &lt;MowerExternalId&gt; or &lt;MowerExternalId,DurationInMunitesDividedBy10,StartPoint&gt; if
    startMowing is chosen

    :param imow_action: Anything from imow.common.actions
    :param mower_name: sth to identify which mower is used
    :param mower_id: sth to identify which mower is used
    :param mower_external_id:
        necessary identifier for the mowers for actions.
        This is looked up, if only mower_name or mower_id is provided

    :param first_action_value_param: first argument passed into the action call request to the api. Can be one of the following contents:
        A duration: minutes of intented mowing. Used by START_MOWING_FROM_POINT. Defaults to &#39;30&#39; minutes.
        A starttime: a datetime when to start mowing. I.e. &#39;2023-08-12 20:50&#39; used by START_MOWING

    :param second_action_value_param: second argument passed into the action call request to the api. Can be one of the following contents:
        A startpoint: from which the mowing shall start. Used by START_MOWING_FROM_POINT. Defaults to &#39;0&#39;.
        An endtime: a datetime when to stop mowing. I.e. &#39;2023-08-12 20:50&#39; used by START_MOWING
    :return:
    &#34;&#34;&#34;
    if not mower_external_id and not mower_id and not mower_name:
        raise AttributeError(
            &#34;Need some mower to work on. Please specify mower_[name|id|action_id]&#34;
        )
    if not mower_external_id and mower_name:
        mower_external_id = await self.get_mower_action_id_from_name(
            mower_name
        )
    if not mower_external_id and mower_id:
        mower_external_id = await self.get_mower_action_id_from_id(
            mower_id
        )

    if len(mower_external_id) &lt; 16:
        raise AttributeError(
            f&#34;Invalid mower_action_id, need exactly 16 chars, got {len(mower_external_id)} in {mower_external_id}&#34;
        )

    url = f&#34;{IMOW_API_URI}/mower-actions/&#34;

    given_kwargs = kwargs.items()
    if len(given_kwargs) &gt; 0:
        logger.debug(
            &#34;Translating given intent **kwargs to action_value_param&#34;
        )
        for key, value in given_kwargs:
            logger.debug(&#34;  {0} = {1}&#34;.format(key, value))
            if key == &#34;duration&#34;:
                first_action_value_param = value
            if key == &#34;startpoint&#34;:
                second_action_value_param = value

            if key == &#34;starttime&#34;:
                first_action_value_param = self.validate_and_fix_datetime(
                    value
                )
            if key == &#34;endtime&#34;:
                second_action_value_param = self.validate_and_fix_datetime(
                    value
                )

        logger.debug(
            f&#34;  -&gt; first_action_value_param: {first_action_value_param} &#34;
        )
        logger.debug(
            f&#34;  -&gt; second_action_value_param: {second_action_value_param} &#34;
        )

    logger.debug(
        f&#39;Build action object for: {imow_action} -&gt; &#34;{imow_action.value}&#34;&#39;
    )
    # Build other action values depending on given ACTION
    if (
        imow_action == IMowActions.START_MOWING_FROM_POINT
    ):  # Add the duration and startpoint parameter
        duration = (
            str(int(first_action_value_param) / 10)
            if first_action_value_param
            else 30 / 10
        )
        startpoint = (
            str(second_action_value_param)
            if second_action_value_param
            else &#34;0&#34;
        )

        action_value = f&#34;{mower_external_id},{duration},{startpoint}&#34;

    elif (
        imow_action == IMowActions.START_MOWING
    ):  # by start- and/or endtime
        starttime = (
            str(first_action_value_param)
            if first_action_value_param
            else datetime.now().strftime(&#34;%Y-%m-%d %H:%M&#34;)
        )
        endtime = (
            str(second_action_value_param)
            if second_action_value_param != &#34;&#34;
            else None
        )
        if endtime:
            action_value = f&#34;{mower_external_id},{starttime},{endtime}&#34;
        else:
            action_value = f&#34;{mower_external_id},{starttime}&#34;

    else:
        action_value = mower_external_id

    action_object = {
        &#34;actionName&#34;: imow_action.value,
        &#34;actionValue&#34;: action_value
        # &#34;0000000123456789,15,0&#34; &lt;MowerExternalId,DurationInMunitesDividedBy10,StartPoint&gt;
        # &#34;0000000123456789,15,0&#34; &lt;MowerExternalId,StartTime,EndTime&gt;
    }
    logger.debug(
        f&#34;Intent sent as request body to imow api for mower with identifier: &#39;{mower_name}/{mower_id}/{mower_external_id}&#39;&#34;
    )
    logger.info(f&#34;  {action_object}&#34;)

    payload = json.dumps(action_object)

    response = await self.api_request(url, &#34;POST&#34;, payload=payload)
    if response.ok:
        logger.debug(
            f&#34;Success: Created mower (extId:{mower_external_id}) ActionObject with contents:&#34;
        )
        logger.debug(f&#34; {action_object}&#34;)
        logger.debug(f&#34; -&gt; (HTTP Status {response.status})&#34;)
    else:
        logger.error(f&#34;No success with mower-action: {payload}&#34;)
    return response</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.receive_mower_by_id"><code class="name flex">
<span>async def <span class="ident">receive_mower_by_id</span></span>(<span>self, mower_id: str) ‑> <a title="imow.common.mowerstate.MowerState" href="../common/mowerstate.html#imow.common.mowerstate.MowerState">MowerState</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_mower_by_id(self, mower_id: str) -&gt; MowerState:
    logger.debug(f&#34;receive_mower: {mower_id}&#34;)
    response = await self.api_request(
        f&#34;{IMOW_API_URI}/mowers/{mower_id}/&#34;, &#34;GET&#34;
    )
    mower = MowerState(json.loads(await response.text()), self)
    logger.debug(mower)
    return mower</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.receive_mower_by_name"><code class="name flex">
<span>async def <span class="ident">receive_mower_by_name</span></span>(<span>self, mower_name: str) ‑> <a title="imow.common.mowerstate.MowerState" href="../common/mowerstate.html#imow.common.mowerstate.MowerState">MowerState</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_mower_by_name(self, mower_name: str) -&gt; MowerState:
    logger.debug(f&#34;get_mower_from_name: {mower_name}&#34;)
    for mower in await self.receive_mowers():
        if mower.name == mower_name:
            logger.debug(mower)
            return mower
    raise LookupError(
        f&#34;Mower with name {mower_name} not found in upstream&#34;
    )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.receive_mower_start_points"><code class="name flex">
<span>async def <span class="ident">receive_mower_start_points</span></span>(<span>self, mower_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_mower_start_points(self, mower_id: str) -&gt; dict:
    logger.debug(f&#34;receive_mower_start_points: {mower_id}&#34;)
    response = await self.api_request(
        f&#34;{IMOW_API_URI}/mowers/{mower_id}/start-points/&#34;, &#34;GET&#34;
    )
    start_points = json.loads(await response.text())
    for startpoint in start_points:
        logger.debug(f&#34;  - {startpoint}&#34;)
    return start_points</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.receive_mower_statistics"><code class="name flex">
<span>async def <span class="ident">receive_mower_statistics</span></span>(<span>self, mower_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_mower_statistics(self, mower_id: str) -&gt; dict:
    logger.debug(f&#34;receive_mower_statistics: {mower_id}&#34;)
    response = await self.api_request(
        f&#34;{IMOW_API_URI}/mowers/{mower_id}/statistic/&#34;, &#34;GET&#34;
    )
    stats = json.loads(await response.text())
    logger.debug(stats)
    return stats</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.receive_mower_week_mow_time_in_hours"><code class="name flex">
<span>async def <span class="ident">receive_mower_week_mow_time_in_hours</span></span>(<span>self, mower_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_mower_week_mow_time_in_hours(
    self, mower_id: str
) -&gt; dict:
    logger.debug(f&#34;receive_mower_week_mow_time_in_hours: {mower_id}&#34;)
    response = await self.api_request(
        f&#34;{IMOW_API_URI}/mowers/{mower_id}/statistics/week-mow-time-in-hours/&#34;,
        &#34;GET&#34;,
    )
    mow_times = json.loads(await response.text())
    logger.debug(mow_times)
    return mow_times</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.receive_mowers"><code class="name flex">
<span>async def <span class="ident">receive_mowers</span></span>(<span>self) ‑> List[<a title="imow.common.mowerstate.MowerState" href="../common/mowerstate.html#imow.common.mowerstate.MowerState">MowerState</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_mowers(self) -&gt; List[MowerState]:
    logger.debug(&#34;receive_mowers: &#34;)
    mowers = []
    response = await self.api_request(f&#34;{IMOW_API_URI}/mowers/&#34;, &#34;GET&#34;)
    for mower in json.loads(await response.text()):
        mowers.append(MowerState(mower, self))
    for mower in mowers:
        logger.debug(f&#34;  - {mower.name}&#34;)
    return mowers</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.update_setting"><code class="name flex">
<span>async def <span class="ident">update_setting</span></span>(<span>self, mower_id, setting, new_value) ‑> <a title="imow.common.mowerstate.MowerState" href="../common/mowerstate.html#imow.common.mowerstate.MowerState">MowerState</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_setting(self, mower_id, setting, new_value) -&gt; MowerState:
    mower_state = await self.receive_mower_by_id(mower_id)

    payload_fields = {
        &#34;id&#34;: mower_state.id,
        &#34;unitFormat&#34;: mower_state.unitFormat,
        &#34;name&#34;: mower_state.name,
        &#34;teamable&#34;: mower_state.teamable,
        &#34;accountId&#34;: mower_state.accountId,
        &#34;childLock&#34;: mower_state.childLock,
        &#34;corridorMode&#34;: mower_state.corridorMode,
        &#34;mappingIntelligentHomeDrive&#34;: mower_state.mappingIntelligentHomeDrive,
        &#34;rainSensorMode&#34;: mower_state.rainSensorMode,
        &#34;edgeMowingMode&#34;: mower_state.edgeMowingMode,
        &#34;asmEnabled&#34;: mower_state.asmEnabled,
        &#34;gpsProtectionEnabled&#34;: mower_state.gpsProtectionEnabled,
        &#34;automaticModeEnabled&#34;: mower_state.automaticModeEnabled,
        &#34;localTimezoneOffset&#34;: mower_state.localTimezoneOffset,
        &#34;mowingTimeManual&#34;: None,
        &#34;mowingTime&#34;: None,
        &#34;team&#34;: mower_state.team,
        &#34;timeZone&#34;: mower_state.timeZone,
    }
    if payload_fields[setting] != new_value:
        payload_fields[setting] = new_value
        headers = {
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0&#34;,
            &#34;Accept&#34;: &#34;application/json, text/plain, */*&#34;,
            &#34;Accept-Language&#34;: &#34;de,en-US;q=0.7,en;q=0.3&#34;,
            &#34;Content-Type&#34;: &#34;application/json&#34;,
            &#34;Origin&#34;: &#34;https://app.imow.stihl.com&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Referer&#34;: &#34;https://app.imow.stihl.com/&#34;,
            &#34;TE&#34;: &#34;Trailers&#34;,
        }
        response = await self.api_request(
            url=f&#34;{IMOW_API_URI}/mowers/{mower_state.id}/&#34;,
            method=&#34;PUT&#34;,
            payload=json.dumps(payload_fields, indent=2).encode(&#34;utf-8&#34;),
            headers=headers,
        )
        mower_state.replace_state(json.loads(await response.text()))
        return mower_state

    else:
        logger.info(f&#34;{setting} is already {new_value}.&#34;)
        return await self.receive_mower_by_id(mower_id)</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.validate_and_fix_datetime"><code class="name flex">
<span>def <span class="ident">validate_and_fix_datetime</span></span>(<span>self, value) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Try to convert and validate the given string from "%Y-%m-%d %H:%M" or "%Y-%m-%d %H:%M:%S into a datetime object and give the needed "%Y-%m-%d %H:%M" string back.
:param value: the string tobe checked
:return: the correctly formated string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_fix_datetime(self, value) -&gt; str:
    &#34;&#34;&#34;
    Try to convert and validate the given string from &#34;%Y-%m-%d %H:%M&#34; or &#34;%Y-%m-%d %H:%M:%S into a datetime object and give the needed &#34;%Y-%m-%d %H:%M&#34; string back.
    :param value: the string tobe checked
    :return: the correctly formated string
    &#34;&#34;&#34;
    try:
        datetime_object = datetime.strptime(value, &#34;%Y-%m-%d %H:%M&#34;)
        return datetime_object.strftime(&#34;%Y-%m-%d %H:%M&#34;)
    except ValueError as ve:
        logger.warn(
            f&#34;  Try fixing given time format because {ve} in {value}&#34;
        )
        try:
            datetime_object = datetime.strptime(value, &#34;%Y-%m-%d %H:%M:%S&#34;)
            return datetime_object.strftime(&#34;%Y-%m-%d %H:%M&#34;)
        except ValueError as ve2:
            raise ValueError(
                f&#39;Unsupported &#34;time&#34; argument: {value} -&gt; {ve2}&#39;
            )</code></pre>
</details>
</dd>
<dt id="imow.api.IMowApi.validate_token"><code class="name flex">
<span>async def <span class="ident">validate_token</span></span>(<span>self, explicit_token: str = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def validate_token(self, explicit_token: str = None) -&gt; bool:
    old_token = None
    if explicit_token:
        # save old instance token and place temp token for validation
        old_token = self.access_token
        self.access_token = explicit_token

    await self.receive_mowers()

    if explicit_token:
        # Reset instance token
        self.access_token = old_token
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="imow" href="../index.html">imow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="imow.api.IMowApi" href="#imow.api.IMowApi">IMowApi</a></code></h4>
<ul class="">
<li><code><a title="imow.api.IMowApi.api_logout" href="#imow.api.IMowApi.api_logout">api_logout</a></code></li>
<li><code><a title="imow.api.IMowApi.api_request" href="#imow.api.IMowApi.api_request">api_request</a></code></li>
<li><code><a title="imow.api.IMowApi.check_api_maintenance" href="#imow.api.IMowApi.check_api_maintenance">check_api_maintenance</a></code></li>
<li><code><a title="imow.api.IMowApi.close" href="#imow.api.IMowApi.close">close</a></code></li>
<li><code><a title="imow.api.IMowApi.fetch_messages" href="#imow.api.IMowApi.fetch_messages">fetch_messages</a></code></li>
<li><code><a title="imow.api.IMowApi.get_mower_action_id_from_id" href="#imow.api.IMowApi.get_mower_action_id_from_id">get_mower_action_id_from_id</a></code></li>
<li><code><a title="imow.api.IMowApi.get_mower_action_id_from_name" href="#imow.api.IMowApi.get_mower_action_id_from_name">get_mower_action_id_from_name</a></code></li>
<li><code><a title="imow.api.IMowApi.get_mower_id_from_name" href="#imow.api.IMowApi.get_mower_id_from_name">get_mower_id_from_name</a></code></li>
<li><code><a title="imow.api.IMowApi.get_status_by_action_id" href="#imow.api.IMowApi.get_status_by_action_id">get_status_by_action_id</a></code></li>
<li><code><a title="imow.api.IMowApi.get_status_by_id" href="#imow.api.IMowApi.get_status_by_id">get_status_by_id</a></code></li>
<li><code><a title="imow.api.IMowApi.get_status_by_name" href="#imow.api.IMowApi.get_status_by_name">get_status_by_name</a></code></li>
<li><code><a title="imow.api.IMowApi.get_token" href="#imow.api.IMowApi.get_token">get_token</a></code></li>
<li><code><a title="imow.api.IMowApi.intent" href="#imow.api.IMowApi.intent">intent</a></code></li>
<li><code><a title="imow.api.IMowApi.receive_mower_by_id" href="#imow.api.IMowApi.receive_mower_by_id">receive_mower_by_id</a></code></li>
<li><code><a title="imow.api.IMowApi.receive_mower_by_name" href="#imow.api.IMowApi.receive_mower_by_name">receive_mower_by_name</a></code></li>
<li><code><a title="imow.api.IMowApi.receive_mower_start_points" href="#imow.api.IMowApi.receive_mower_start_points">receive_mower_start_points</a></code></li>
<li><code><a title="imow.api.IMowApi.receive_mower_statistics" href="#imow.api.IMowApi.receive_mower_statistics">receive_mower_statistics</a></code></li>
<li><code><a title="imow.api.IMowApi.receive_mower_week_mow_time_in_hours" href="#imow.api.IMowApi.receive_mower_week_mow_time_in_hours">receive_mower_week_mow_time_in_hours</a></code></li>
<li><code><a title="imow.api.IMowApi.receive_mowers" href="#imow.api.IMowApi.receive_mowers">receive_mowers</a></code></li>
<li><code><a title="imow.api.IMowApi.update_setting" href="#imow.api.IMowApi.update_setting">update_setting</a></code></li>
<li><code><a title="imow.api.IMowApi.validate_and_fix_datetime" href="#imow.api.IMowApi.validate_and_fix_datetime">validate_and_fix_datetime</a></code></li>
<li><code><a title="imow.api.IMowApi.validate_token" href="#imow.api.IMowApi.validate_token">validate_token</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>